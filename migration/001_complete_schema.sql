-- ============================================================
-- RankMe Complete Schema Migration
-- Compatible with Supabase CLI: supabase db push
-- Run this FIRST before importing data
-- ============================================================

-- 1. ENUMS
CREATE TYPE public.app_role AS ENUM ('admin', 'moderator', 'user');

-- 2. TABLES (ordered by dependency)

-- profiles (referenced by almost everything)
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY,
  username text,
  display_name text,
  avatar_url text,
  country text DEFAULT 'US',
  tier text DEFAULT 'bronze',
  total_points integer DEFAULT 0,
  weekly_points integer DEFAULT 0,
  accuracy numeric DEFAULT 0,
  total_quizzes_completed integer DEFAULT 0,
  total_correct_answers integer DEFAULT 0,
  total_questions_answered integer DEFAULT 0,
  current_streak integer DEFAULT 0,
  longest_streak integer DEFAULT 0,
  last_active_date date,
  chat_streak integer DEFAULT 0,
  last_chat_date date,
  is_admin boolean DEFAULT false,
  is_premium boolean DEFAULT false,
  premium_expires_at timestamptz,
  bank_name text,
  account_number text,
  account_name text,
  last_payment_reference text,
  showcase_badges text[] DEFAULT '{}',
  equipped_title text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- subjects
CREATE TABLE public.subjects (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  icon text,
  color text DEFAULT '#4361EE',
  description text,
  question_count integer DEFAULT 0,
  created_at timestamptz DEFAULT now()
);

-- questions
CREATE TABLE public.questions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subject_id integer REFERENCES public.subjects(id),
  question_text text NOT NULL,
  option_a text NOT NULL,
  option_b text NOT NULL,
  option_c text NOT NULL,
  option_d text NOT NULL,
  correct_answer character(1) NOT NULL,
  explanation text,
  difficulty text DEFAULT 'medium',
  points_value integer DEFAULT 100,
  created_at timestamptz DEFAULT now()
);

-- badges
CREATE TABLE public.badges (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL UNIQUE,
  description text,
  icon text,
  requirement_type text,
  requirement_value integer,
  tier text,
  created_at timestamptz DEFAULT now()
);

-- battles
CREATE TABLE public.battles (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  created_by uuid REFERENCES public.profiles(id),
  subject_id integer REFERENCES public.subjects(id),
  winner_id uuid REFERENCES public.profiles(id),
  status text DEFAULT 'waiting',
  mode text DEFAULT '1v1',
  room_code text UNIQUE,
  is_private boolean DEFAULT false,
  total_questions integer DEFAULT 10,
  time_per_question integer DEFAULT 20,
  started_at timestamptz,
  completed_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- battle_participants
CREATE TABLE public.battle_participants (
  battle_id uuid NOT NULL REFERENCES public.battles(id),
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  id uuid DEFAULT gen_random_uuid(),
  score integer DEFAULT 0,
  answers_correct integer DEFAULT 0,
  correct_answers integer DEFAULT 0,
  total_time integer DEFAULT 0,
  status text DEFAULT 'joined',
  ready boolean DEFAULT false,
  joined_at timestamptz DEFAULT now(),
  ready_at timestamptz,
  finished_at timestamptz,
  PRIMARY KEY (battle_id, user_id)
);

-- battle_questions
CREATE TABLE public.battle_questions (
  battle_id uuid NOT NULL REFERENCES public.battles(id),
  question_id bigint NOT NULL REFERENCES public.questions(id),
  order_index integer NOT NULL,
  PRIMARY KEY (battle_id, question_id)
);

-- battle_answers
CREATE TABLE public.battle_answers (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  battle_id uuid REFERENCES public.battles(id),
  user_id uuid REFERENCES public.profiles(id),
  question_id bigint REFERENCES public.questions(id),
  selected_answer character(1),
  is_correct boolean DEFAULT false,
  time_spent integer,
  points_earned integer DEFAULT 0,
  answered_at timestamptz DEFAULT now(),
  UNIQUE (battle_id, user_id, question_id)
);
CREATE INDEX idx_battle_answers_battle ON public.battle_answers(battle_id);
CREATE INDEX idx_battle_answers_user ON public.battle_answers(user_id);

-- battle_live_state
CREATE TABLE public.battle_live_state (
  battle_id uuid NOT NULL PRIMARY KEY REFERENCES public.battles(id),
  current_question integer DEFAULT 1,
  question_start_time timestamptz,
  status_data jsonb DEFAULT '{}',
  updated_at timestamptz DEFAULT now()
);

-- quiz_sessions
CREATE TABLE public.quiz_sessions (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  subject_id integer REFERENCES public.subjects(id),
  subject_name text,
  score integer DEFAULT 0,
  total_questions integer DEFAULT 0,
  correct_answers integer DEFAULT 0,
  accuracy numeric DEFAULT 0,
  time_taken integer,
  completed_at timestamptz,
  created_at timestamptz DEFAULT now()
);

-- quiz_results
CREATE TABLE public.quiz_results (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL,
  subject text NOT NULL,
  total_questions integer NOT NULL,
  correct_answers integer NOT NULL,
  total_points integer NOT NULL,
  accuracy numeric NOT NULL,
  average_time numeric NOT NULL,
  perfect_streak integer DEFAULT 0,
  completed_at timestamptz DEFAULT now()
);

-- user_answers
CREATE TABLE public.user_answers (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id uuid NOT NULL REFERENCES public.quiz_sessions(id),
  question_id bigint REFERENCES public.questions(id),
  selected_answer character(1),
  is_correct boolean DEFAULT false,
  time_spent integer,
  points_earned integer DEFAULT 0,
  answered_at timestamptz DEFAULT now()
);

-- user_progress
CREATE TABLE public.user_progress (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL,
  subject text NOT NULL,
  questions_attempted integer DEFAULT 0,
  questions_correct integer DEFAULT 0,
  high_score integer DEFAULT 0,
  last_played_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- leaderboard_entries
CREATE TABLE public.leaderboard_entries (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  profile_id uuid NOT NULL REFERENCES public.profiles(id),
  period text NOT NULL,
  subject text,
  points integer DEFAULT 0,
  rank integer,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE (profile_id, period, subject)
);
CREATE INDEX idx_leaderboard_entries_period_points ON public.leaderboard_entries(period, points DESC);

-- friendships
CREATE TABLE public.friendships (
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  friend_id uuid NOT NULL REFERENCES public.profiles(id),
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (user_id, friend_id)
);

-- friend_requests
CREATE TABLE public.friend_requests (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  from_user_id uuid NOT NULL REFERENCES public.profiles(id),
  to_user_id uuid NOT NULL REFERENCES public.profiles(id),
  status text DEFAULT 'pending',
  created_at timestamptz DEFAULT now(),
  responded_at timestamptz
);

-- direct_messages
CREATE TABLE public.direct_messages (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  sender_id uuid NOT NULL REFERENCES public.profiles(id),
  receiver_id uuid NOT NULL REFERENCES public.profiles(id),
  message text NOT NULL,
  message_type text DEFAULT 'text',
  media_url text,
  gif_url text,
  thumbnail_url text,
  file_name text,
  file_size integer,
  duration integer,
  width integer,
  height integer,
  status text DEFAULT 'sent',
  is_read boolean DEFAULT false,
  reply_to_id uuid REFERENCES public.direct_messages(id),
  created_at timestamptz DEFAULT now()
);
CREATE INDEX idx_direct_messages_sender ON public.direct_messages(sender_id);
CREATE INDEX idx_direct_messages_receiver ON public.direct_messages(receiver_id);
CREATE INDEX idx_direct_messages_status ON public.direct_messages(status) WHERE status <> 'read';
CREATE INDEX idx_direct_messages_reply_to ON public.direct_messages(reply_to_id) WHERE reply_to_id IS NOT NULL;

-- message_reactions
CREATE TABLE public.message_reactions (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  message_id uuid REFERENCES public.direct_messages(id),
  user_id uuid REFERENCES public.profiles(id),
  emoji text NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- daily_challenges
CREATE TABLE public.daily_challenges (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  challenge_date date NOT NULL UNIQUE,
  question_ids integer[] NOT NULL,
  total_questions integer NOT NULL DEFAULT 10,
  time_limit_seconds integer NOT NULL DEFAULT 600,
  created_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX idx_daily_challenges_date ON public.daily_challenges(challenge_date DESC);

-- daily_challenge_attempts
CREATE TABLE public.daily_challenge_attempts (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  challenge_id uuid NOT NULL REFERENCES public.daily_challenges(id),
  score integer NOT NULL DEFAULT 0,
  correct_answers integer NOT NULL DEFAULT 0,
  total_questions integer NOT NULL DEFAULT 0,
  accuracy numeric NOT NULL DEFAULT 0,
  time_taken_seconds integer NOT NULL DEFAULT 0,
  completed_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (user_id, challenge_id)
);
CREATE INDEX idx_daily_attempts_challenge ON public.daily_challenge_attempts(challenge_id);
CREATE INDEX idx_daily_attempts_user ON public.daily_challenge_attempts(user_id);

-- daily_leaderboards
CREATE TABLE public.daily_leaderboards (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  challenge_id uuid NOT NULL REFERENCES public.daily_challenges(id),
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  rank integer NOT NULL,
  score integer NOT NULL,
  accuracy numeric NOT NULL,
  time_taken_seconds integer NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (challenge_id, user_id)
);
CREATE INDEX idx_daily_leaderboards_challenge ON public.daily_leaderboards(challenge_id, rank);

-- daily_streaks
CREATE TABLE public.daily_streaks (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL,
  streak_date date NOT NULL,
  points_earned integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  UNIQUE (user_id, streak_date)
);

-- notifications
CREATE TABLE public.notifications (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  type text,
  title text,
  message text,
  data jsonb,
  read boolean DEFAULT false,
  created_at timestamptz DEFAULT now()
);

-- payments
CREATE TABLE public.payments (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  reference text NOT NULL,
  amount integer NOT NULL,
  currency text DEFAULT 'NGN',
  status text DEFAULT 'pending',
  channel text,
  metadata jsonb,
  paid_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- subscriptions
CREATE TABLE public.subscriptions (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL UNIQUE REFERENCES public.profiles(id),
  plan text DEFAULT 'premium',
  status text DEFAULT 'active',
  current_period_start timestamptz DEFAULT now(),
  current_period_end timestamptz,
  created_at timestamptz DEFAULT now()
);

-- user_achievements
CREATE TABLE public.user_achievements (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL,
  achievement_id text NOT NULL,
  earned_at timestamptz DEFAULT now()
);

-- user_badges
CREATE TABLE public.user_badges (
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  badge_id integer NOT NULL REFERENCES public.badges(id),
  earned_at timestamptz DEFAULT now(),
  PRIMARY KEY (user_id, badge_id)
);

-- user_roles
CREATE TABLE public.user_roles (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL,
  role app_role NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- admin_actions
CREATE TABLE public.admin_actions (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_id uuid NOT NULL REFERENCES public.profiles(id),
  target_user_id uuid REFERENCES public.profiles(id),
  action_type text NOT NULL,
  details jsonb,
  created_at timestamptz DEFAULT now()
);

-- ai_summary_jobs
CREATE TABLE public.ai_summary_jobs (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  file_name text,
  file_url text,
  status text DEFAULT 'processing',
  summary_text text,
  created_at timestamptz DEFAULT now(),
  completed_at timestamptz
);


-- ============================================================
-- 3. DATABASE FUNCTIONS
-- ============================================================

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger LANGUAGE plpgsql SET search_path TO 'public' AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  INSERT INTO public.profiles (id, username, display_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data ->> 'username',
    COALESCE(NEW.raw_user_meta_data ->> 'display_name', NEW.raw_user_meta_data ->> 'username'),
    NEW.raw_user_meta_data ->> 'avatar_url'
  );
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.increment_user_points(p_user_id uuid, p_points_to_add integer, p_weekly_points_to_add integer, p_increment_quizzes integer)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  UPDATE public.profiles SET 
    total_points = COALESCE(total_points, 0) + p_points_to_add,
    weekly_points = COALESCE(weekly_points, 0) + p_weekly_points_to_add,
    total_quizzes_completed = COALESCE(total_quizzes_completed, 0) + p_increment_quizzes,
    updated_at = NOW()
  WHERE id = p_user_id;
END;
$$;

CREATE OR REPLACE FUNCTION public.has_role(_user_id uuid, _role app_role)
RETURNS boolean LANGUAGE sql STABLE SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = _user_id AND role = _role);
$$;

CREATE OR REPLACE FUNCTION public.get_or_create_daily_challenge()
RETURNS uuid LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE
  challenge_id UUID;
  today_date DATE := CURRENT_DATE;
  question_array INTEGER[];
BEGIN
  SELECT id INTO challenge_id FROM public.daily_challenges WHERE challenge_date = today_date;
  IF challenge_id IS NULL THEN
    SELECT ARRAY(SELECT id FROM public.questions ORDER BY RANDOM() LIMIT 10) INTO question_array;
    INSERT INTO public.daily_challenges (challenge_date, question_ids, total_questions)
    VALUES (today_date, question_array, 10) RETURNING id INTO challenge_id;
  END IF;
  RETURN challenge_id;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_battle_score(battle_id_param uuid, user_id_param uuid, points_to_add integer, correct_to_add integer, time_to_add integer)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  UPDATE battle_participants SET 
    score = COALESCE(score, 0) + points_to_add,
    correct_answers = COALESCE(correct_answers, 0) + correct_to_add,
    total_time = COALESCE(total_time, 0) + time_to_add
  WHERE battle_id = battle_id_param AND user_id = user_id_param;
END;
$$;

CREATE OR REPLACE FUNCTION public.recalculate_leaderboard_ranks()
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  WITH ranked AS (
    SELECT id, ROW_NUMBER() OVER (ORDER BY points DESC NULLS LAST) as new_rank
    FROM public.leaderboard_entries WHERE period = 'all_time' AND subject IS NULL
  )
  UPDATE public.leaderboard_entries le SET rank = r.new_rank FROM ranked r WHERE le.id = r.id;
  
  WITH ranked AS (
    SELECT id, ROW_NUMBER() OVER (ORDER BY points DESC NULLS LAST) as new_rank
    FROM public.leaderboard_entries WHERE period = 'weekly' AND subject IS NULL
  )
  UPDATE public.leaderboard_entries le SET rank = r.new_rank FROM ranked r WHERE le.id = r.id;
END;
$$;

CREATE OR REPLACE FUNCTION public.check_premium_expiry(user_uuid uuid)
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE
  expires_at TIMESTAMP WITH TIME ZONE;
  current_premium BOOLEAN;
BEGIN
  SELECT is_premium, premium_expires_at INTO current_premium, expires_at FROM public.profiles WHERE id = user_uuid;
  IF current_premium = true AND expires_at IS NOT NULL AND expires_at < NOW() THEN
    UPDATE public.profiles SET is_premium = false, updated_at = NOW() WHERE id = user_uuid;
    RETURN false;
  END IF;
  RETURN COALESCE(current_premium, false);
END;
$$;

CREATE OR REPLACE FUNCTION public.update_daily_leaderboard_ranks(p_challenge_id uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  DELETE FROM public.daily_leaderboards WHERE challenge_id = p_challenge_id;
  INSERT INTO public.daily_leaderboards (challenge_id, user_id, rank, score, accuracy, time_taken_seconds)
  SELECT p_challenge_id, user_id,
    ROW_NUMBER() OVER (ORDER BY score DESC, time_taken_seconds ASC) as rank,
    score, accuracy, time_taken_seconds
  FROM public.daily_challenge_attempts WHERE challenge_id = p_challenge_id;
END;
$$;

CREATE OR REPLACE FUNCTION public.trigger_update_daily_leaderboard()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  PERFORM public.update_daily_leaderboard_ranks(NEW.challenge_id);
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_rank(user_uuid uuid)
RETURNS TABLE(rank bigint, total_points integer, percentile numeric)
LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  RETURN QUERY
  WITH ranked AS (
    SELECT p.id, p.total_points as points,
      ROW_NUMBER() OVER (ORDER BY p.total_points DESC) as user_rank,
      COUNT(*) OVER () as total_users
    FROM public.profiles p WHERE p.total_points > 0
  )
  SELECT r.user_rank, r.points,
    ROUND(((r.total_users - r.user_rank + 1)::DECIMAL / r.total_users) * 100, 1)
  FROM ranked r WHERE r.id = user_uuid;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_user_streak(user_uuid uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE
  last_date DATE; current_streak_val INTEGER;
BEGIN
  SELECT last_active_date, current_streak INTO last_date, current_streak_val FROM public.profiles WHERE id = user_uuid;
  IF last_date IS NULL OR last_date < CURRENT_DATE - INTERVAL '1 day' THEN
    UPDATE public.profiles SET current_streak = 1, last_active_date = CURRENT_DATE, updated_at = NOW() WHERE id = user_uuid;
  ELSIF last_date = CURRENT_DATE - INTERVAL '1 day' THEN
    UPDATE public.profiles SET current_streak = current_streak + 1, longest_streak = GREATEST(longest_streak, current_streak + 1), last_active_date = CURRENT_DATE, updated_at = NOW() WHERE id = user_uuid;
  END IF;
  INSERT INTO public.daily_streaks (user_id, streak_date, points_earned) VALUES (user_uuid, CURRENT_DATE, 0) ON CONFLICT DO NOTHING;
END;
$$;

CREATE OR REPLACE FUNCTION public.sync_leaderboard_on_points_change()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE calculated_tier TEXT;
BEGIN
  calculated_tier := CASE
    WHEN COALESCE(NEW.total_points, 0) >= 50000 THEN 'champion'
    WHEN COALESCE(NEW.total_points, 0) >= 30000 THEN 'diamond'
    WHEN COALESCE(NEW.total_points, 0) >= 15000 THEN 'platinum'
    WHEN COALESCE(NEW.total_points, 0) >= 7500 THEN 'gold'
    WHEN COALESCE(NEW.total_points, 0) >= 3000 THEN 'silver'
    ELSE 'bronze'
  END;
  IF NEW.tier IS DISTINCT FROM calculated_tier THEN NEW.tier := calculated_tier; END IF;
  INSERT INTO public.leaderboard_entries (profile_id, period, subject, points, updated_at)
  VALUES (NEW.id, 'all_time', NULL, COALESCE(NEW.total_points, 0), NOW())
  ON CONFLICT (profile_id, period, subject) DO UPDATE SET points = COALESCE(NEW.total_points, 0), updated_at = NOW();
  INSERT INTO public.leaderboard_entries (profile_id, period, subject, points, updated_at)
  VALUES (NEW.id, 'weekly', NULL, COALESCE(NEW.weekly_points, 0), NOW())
  ON CONFLICT (profile_id, period, subject) DO UPDATE SET points = COALESCE(NEW.weekly_points, 0), updated_at = NOW();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_chat_streak(user_uuid uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE last_date DATE; current_chat_streak INTEGER;
BEGIN
  SELECT last_chat_date, chat_streak INTO last_date, current_chat_streak FROM public.profiles WHERE id = user_uuid;
  IF last_date IS NULL OR last_date < CURRENT_DATE - INTERVAL '1 day' THEN
    UPDATE public.profiles SET chat_streak = 1, last_chat_date = CURRENT_DATE, updated_at = NOW() WHERE id = user_uuid;
  ELSIF last_date = CURRENT_DATE - INTERVAL '1 day' THEN
    UPDATE public.profiles SET chat_streak = COALESCE(chat_streak, 0) + 1, last_chat_date = CURRENT_DATE, updated_at = NOW() WHERE id = user_uuid;
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION public.check_and_award_badges(user_uuid uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE
  user_points INTEGER; user_streak INTEGER; user_accuracy DECIMAL; user_quizzes INTEGER;
  badge_record RECORD;
BEGIN
  SELECT total_points, current_streak, accuracy, total_quizzes_completed 
  INTO user_points, user_streak, user_accuracy, user_quizzes FROM public.profiles WHERE id = user_uuid;
  FOR badge_record IN SELECT * FROM public.badges WHERE id NOT IN (SELECT badge_id FROM public.user_badges WHERE user_id = user_uuid) LOOP
    CASE badge_record.requirement_type
      WHEN 'points' THEN IF user_points >= badge_record.requirement_value THEN INSERT INTO public.user_badges (user_id, badge_id) VALUES (user_uuid, badge_record.id) ON CONFLICT DO NOTHING; END IF;
      WHEN 'streak' THEN IF user_streak >= badge_record.requirement_value THEN INSERT INTO public.user_badges (user_id, badge_id) VALUES (user_uuid, badge_record.id) ON CONFLICT DO NOTHING; END IF;
      WHEN 'accuracy' THEN IF user_accuracy >= badge_record.requirement_value THEN INSERT INTO public.user_badges (user_id, badge_id) VALUES (user_uuid, badge_record.id) ON CONFLICT DO NOTHING; END IF;
      WHEN 'quizzes' THEN IF user_quizzes >= badge_record.requirement_value THEN INSERT INTO public.user_badges (user_id, badge_id) VALUES (user_uuid, badge_record.id) ON CONFLICT DO NOTHING; END IF;
      ELSE NULL;
    END CASE;
  END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_user_stats_after_quiz()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
DECLARE new_total_points INTEGER; new_tier TEXT;
BEGIN
  new_total_points := COALESCE((SELECT total_points FROM public.profiles WHERE id = NEW.user_id), 0) + COALESCE(NEW.score, 0);
  new_tier := CASE
    WHEN new_total_points >= 50000 THEN 'champion'
    WHEN new_total_points >= 30000 THEN 'diamond'
    WHEN new_total_points >= 15000 THEN 'platinum'
    WHEN new_total_points >= 7500 THEN 'gold'
    WHEN new_total_points >= 3000 THEN 'silver'
    ELSE 'bronze'
  END;
  UPDATE public.profiles SET 
    total_points = new_total_points, tier = new_tier,
    total_quizzes_completed = COALESCE(total_quizzes_completed, 0) + 1,
    total_correct_answers = COALESCE(total_correct_answers, 0) + NEW.correct_answers,
    total_questions_answered = COALESCE(total_questions_answered, 0) + NEW.total_questions,
    accuracy = CASE WHEN COALESCE(total_questions_answered, 0) + NEW.total_questions > 0 
      THEN ((COALESCE(total_correct_answers, 0) + NEW.correct_answers)::DECIMAL / (COALESCE(total_questions_answered, 0) + NEW.total_questions)) * 100 ELSE 0 END,
    last_active_date = CURRENT_DATE, updated_at = NOW()
  WHERE id = NEW.user_id;
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_leaderboard_entries()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  INSERT INTO public.leaderboard_entries (profile_id, period, points, updated_at) VALUES (NEW.id, 'all_time', NEW.total_points, NOW())
  ON CONFLICT (profile_id, period, subject) DO UPDATE SET points = NEW.total_points, updated_at = NOW();
  INSERT INTO public.leaderboard_entries (profile_id, period, points, updated_at) VALUES (NEW.id, 'weekly', NEW.weekly_points, NOW())
  ON CONFLICT (profile_id, period, subject) DO UPDATE SET points = NEW.weekly_points, updated_at = NOW();
  RETURN NEW;
END;
$$;


-- ============================================================
-- 4. TRIGGERS
-- ============================================================

-- Auth trigger (create profile on signup)
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Profile triggers
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER sync_leaderboard_trigger AFTER INSERT OR UPDATE OF total_points, weekly_points ON public.profiles FOR EACH ROW EXECUTE FUNCTION sync_leaderboard_on_points_change();
CREATE TRIGGER on_profile_points_updated AFTER UPDATE OF total_points, weekly_points ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_leaderboard_entries();

-- Quiz trigger
CREATE TRIGGER on_quiz_session_completed AFTER INSERT ON public.quiz_sessions FOR EACH ROW WHEN (NEW.completed_at IS NOT NULL) EXECUTE FUNCTION update_user_stats_after_quiz();

-- Daily challenge trigger
CREATE TRIGGER on_daily_attempt_insert AFTER INSERT ON public.daily_challenge_attempts FOR EACH ROW EXECUTE FUNCTION trigger_update_daily_leaderboard();

-- Payments trigger
CREATE TRIGGER update_payments_updated_at BEFORE UPDATE ON public.payments FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- User progress trigger
CREATE TRIGGER update_user_progress_updated_at BEFORE UPDATE ON public.user_progress FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


-- ============================================================
-- 5. ROW LEVEL SECURITY
-- ============================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subjects ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.badges ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.battles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.battle_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.battle_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.battle_answers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.battle_live_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.quiz_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.quiz_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_answers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.leaderboard_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.friendships ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.friend_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.direct_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.message_reactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_challenge_attempts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_leaderboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_streaks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_badges ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_actions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_summary_jobs ENABLE ROW LEVEL SECURITY;

-- profiles
CREATE POLICY "Profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- subjects
CREATE POLICY "Subjects are viewable by everyone" ON public.subjects FOR SELECT USING (true);

-- questions
CREATE POLICY "Questions are viewable by everyone" ON public.questions FOR SELECT USING (true);
CREATE POLICY "Admins can insert questions" ON public.questions FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin') OR
  EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.is_admin = true)
);
CREATE POLICY "Admins can update questions" ON public.questions FOR UPDATE USING (
  EXISTS (SELECT 1 FROM user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin') OR
  EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.is_admin = true)
);
CREATE POLICY "Admins can delete questions" ON public.questions FOR DELETE USING (
  EXISTS (SELECT 1 FROM user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin') OR
  EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.is_admin = true)
);

-- badges
CREATE POLICY "Badges are viewable by everyone" ON public.badges FOR SELECT USING (true);

-- battles
CREATE POLICY "Battles are viewable by everyone" ON public.battles FOR SELECT USING (true);
CREATE POLICY "Authenticated users can create battles" ON public.battles FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY "Authenticated users can update battles" ON public.battles FOR UPDATE USING (auth.uid() IS NOT NULL);

-- battle_participants
CREATE POLICY "Battle participants viewable by everyone" ON public.battle_participants FOR SELECT USING (true);
CREATE POLICY "Users can join battles" ON public.battle_participants FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own battle score" ON public.battle_participants FOR UPDATE USING (auth.uid() = user_id);

-- battle_questions
CREATE POLICY "Battle questions viewable by participants" ON public.battle_questions FOR SELECT USING (
  EXISTS (SELECT 1 FROM battle_participants bp WHERE bp.battle_id = battle_questions.battle_id AND bp.user_id = auth.uid())
);

-- battle_answers
CREATE POLICY "Battle answers viewable by participants" ON public.battle_answers FOR SELECT USING (
  EXISTS (SELECT 1 FROM battle_participants bp WHERE bp.battle_id = battle_answers.battle_id AND bp.user_id = auth.uid())
);
CREATE POLICY "Users can insert own battle answers" ON public.battle_answers FOR INSERT WITH CHECK (auth.uid() = user_id);

-- battle_live_state
CREATE POLICY "Battle live state viewable by participants" ON public.battle_live_state FOR SELECT USING (
  EXISTS (SELECT 1 FROM battle_participants bp WHERE bp.battle_id = battle_live_state.battle_id AND bp.user_id = auth.uid())
);
CREATE POLICY "Battle live state insertable by participants" ON public.battle_live_state FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM battle_participants bp WHERE bp.battle_id = battle_live_state.battle_id AND bp.user_id = auth.uid())
);
CREATE POLICY "Battle live state updatable by participants" ON public.battle_live_state FOR UPDATE USING (
  EXISTS (SELECT 1 FROM battle_participants bp WHERE bp.battle_id = battle_live_state.battle_id AND bp.user_id = auth.uid())
);

-- quiz_sessions
CREATE POLICY "Users can view own quiz sessions" ON public.quiz_sessions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own quiz sessions" ON public.quiz_sessions FOR INSERT WITH CHECK (auth.uid() = user_id);

-- quiz_results
CREATE POLICY "Users can view own quiz results" ON public.quiz_results FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own quiz results" ON public.quiz_results FOR INSERT WITH CHECK (auth.uid() = user_id);

-- user_answers
CREATE POLICY "Users can view own answers" ON public.user_answers FOR SELECT USING (
  EXISTS (SELECT 1 FROM quiz_sessions WHERE quiz_sessions.id = user_answers.session_id AND quiz_sessions.user_id = auth.uid())
);
CREATE POLICY "Users can insert own answers" ON public.user_answers FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM quiz_sessions WHERE quiz_sessions.id = user_answers.session_id AND quiz_sessions.user_id = auth.uid())
);

-- user_progress
CREATE POLICY "Users can view own progress" ON public.user_progress FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own progress" ON public.user_progress FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own progress" ON public.user_progress FOR UPDATE USING (auth.uid() = user_id);

-- leaderboard_entries
CREATE POLICY "Leaderboard is viewable by everyone" ON public.leaderboard_entries FOR SELECT USING (true);
CREATE POLICY "System can insert leaderboard entries" ON public.leaderboard_entries FOR INSERT WITH CHECK (auth.uid() = profile_id);
CREATE POLICY "System can update leaderboard entries" ON public.leaderboard_entries FOR UPDATE USING (auth.uid() = profile_id);

-- friendships
CREATE POLICY "Users can view their friendships" ON public.friendships FOR SELECT USING (auth.uid() = user_id OR auth.uid() = friend_id);
CREATE POLICY "System can manage friendships" ON public.friendships FOR INSERT WITH CHECK (auth.uid() = user_id OR auth.uid() = friend_id);

-- friend_requests
CREATE POLICY "Users can view their friend requests" ON public.friend_requests FOR SELECT USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);
CREATE POLICY "Users can send friend requests" ON public.friend_requests FOR INSERT WITH CHECK (auth.uid() = from_user_id);
CREATE POLICY "Users can update requests they received" ON public.friend_requests FOR UPDATE USING (auth.uid() = to_user_id);

-- direct_messages
CREATE POLICY "Users can view their messages" ON public.direct_messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages" ON public.direct_messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update received messages" ON public.direct_messages FOR UPDATE USING (auth.uid() = receiver_id);

-- message_reactions
CREATE POLICY "Users can view reactions on messages they can see" ON public.message_reactions FOR SELECT USING (
  EXISTS (SELECT 1 FROM direct_messages dm WHERE dm.id = message_reactions.message_id AND (dm.sender_id = auth.uid() OR dm.receiver_id = auth.uid()))
);
CREATE POLICY "Users can add reactions to messages they can see" ON public.message_reactions FOR INSERT WITH CHECK (
  auth.uid() = user_id AND EXISTS (SELECT 1 FROM direct_messages dm WHERE dm.id = message_reactions.message_id AND (dm.sender_id = auth.uid() OR dm.receiver_id = auth.uid()))
);
CREATE POLICY "Users can remove their own reactions" ON public.message_reactions FOR DELETE USING (auth.uid() = user_id);

-- daily_challenges
CREATE POLICY "Anyone can view daily challenges" ON public.daily_challenges FOR SELECT USING (true);

-- daily_challenge_attempts
CREATE POLICY "Users can view all attempts for leaderboard" ON public.daily_challenge_attempts FOR SELECT USING (true);
CREATE POLICY "Users can insert their own attempts" ON public.daily_challenge_attempts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own attempts" ON public.daily_challenge_attempts FOR UPDATE USING (auth.uid() = user_id);

-- daily_leaderboards
CREATE POLICY "Anyone can view leaderboards" ON public.daily_leaderboards FOR SELECT USING (true);
CREATE POLICY "Service role can manage leaderboards" ON public.daily_leaderboards FOR ALL USING (true);

-- daily_streaks
CREATE POLICY "Users can view own streaks" ON public.daily_streaks FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own streaks" ON public.daily_streaks FOR INSERT WITH CHECK (auth.uid() = user_id);

-- notifications
CREATE POLICY "Users can view their notifications" ON public.notifications FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "System can create notifications" ON public.notifications FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can update their notifications" ON public.notifications FOR UPDATE USING (auth.uid() = user_id);

-- payments
CREATE POLICY "Users can view own payments" ON public.payments FOR SELECT USING (auth.uid() = user_id);

-- subscriptions
CREATE POLICY "Users can view own subscription" ON public.subscriptions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own subscription" ON public.subscriptions FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own subscription" ON public.subscriptions FOR UPDATE USING (auth.uid() = user_id);

-- user_achievements
CREATE POLICY "Users can view own achievements" ON public.user_achievements FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own achievements" ON public.user_achievements FOR INSERT WITH CHECK (auth.uid() = user_id);

-- user_badges
CREATE POLICY "User badges are viewable by everyone" ON public.user_badges FOR SELECT USING (true);
CREATE POLICY "System can award badges" ON public.user_badges FOR INSERT WITH CHECK (auth.uid() = user_id);

-- user_roles
CREATE POLICY "Users can read their own roles" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);

-- admin_actions
CREATE POLICY "Admins can view admin actions" ON public.admin_actions FOR SELECT USING (
  EXISTS (SELECT 1 FROM user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin') OR
  EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.is_admin = true)
);
CREATE POLICY "Admins can insert admin actions" ON public.admin_actions FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin') OR
  EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.is_admin = true)
);

-- ai_summary_jobs
CREATE POLICY "Users can view own AI jobs" ON public.ai_summary_jobs FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create AI jobs" ON public.ai_summary_jobs FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own AI jobs" ON public.ai_summary_jobs FOR UPDATE USING (auth.uid() = user_id);


-- ============================================================
-- 6. REALTIME
-- ============================================================

ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
ALTER PUBLICATION supabase_realtime ADD TABLE public.leaderboard_entries;
ALTER PUBLICATION supabase_realtime ADD TABLE public.battles;
ALTER PUBLICATION supabase_realtime ADD TABLE public.battle_participants;
ALTER PUBLICATION supabase_realtime ADD TABLE public.battle_live_state;
ALTER PUBLICATION supabase_realtime ADD TABLE public.direct_messages;
ALTER PUBLICATION supabase_realtime ADD TABLE public.message_reactions;
ALTER PUBLICATION supabase_realtime ADD TABLE public.daily_leaderboards;


-- ============================================================
-- 7. STORAGE
-- ============================================================

INSERT INTO storage.buckets (id, name, public) VALUES ('chat-media', 'chat-media', true);

CREATE POLICY "Anyone can read chat media" ON storage.objects FOR SELECT USING (bucket_id = 'chat-media');
CREATE POLICY "Authenticated users can upload chat media" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'chat-media' AND auth.uid() IS NOT NULL);
